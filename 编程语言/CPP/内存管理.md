## 内存管理

### malloc 和 free

**malloc** 从内存池中提取一块合适的内存，并向该程序返回一个指向这块内存的指针，这块内存此时并没有以任何方式进行初始化（不同于 **new** 和 **calloc**），所以必须对 **malloc** 之后的内存手动进行初始化。

当一块以前分配的内存不再使用时，程序调用 **free** 函数把它归还给内存池供以后之需。调用 **free** 函数之后要手动将指针置为 NULL，不然会有野指针。

注意：

1. **malloc** 返回的是一个 void * 类型的指针，需要手动进行类型转换；
2. 如果操作系统资源不足，无法提供内存，**malloc** 函数就会返回一个 NULL 指针，因此，对每个从 **malloc** 返回的指针都进行检查，确保它并非 NULL 是非常重要的；
3. 另外就是上面提到的手动初始化的问题。

```c++
int main()
{
	int* p = (int *)malloc(8 * sizeof(int));
	if (NULL == p)
	{
		cout << "Out of memory!" << endl;
	}
	free(p);
	p = NULL;

	return 0;
}
```

### calloc 和 realloc

**calloc** 和 **malloc** 之间的主要区别是前者在返回指向内存的指针之前把它初始化为 0，但如果你的程序只是想把一些值存储到数组中，那么这个初始化过程纯属浪费时间。另外就是他们的参数列表不同，**calloc** 的参数包括所需元素的数量和每个元素的字节数。

realloc 函数用于修改一个原先已经分配的内存块的大小。使用这个函数，你可以使一块内存扩大或缩小。如果用于扩大一个内存块，那么这块内存原先的内容依然保留，新增加的内存添加到原先内存块的后面，同样的，**新内存并未以任何方式进行初始化**。如果它用于缩小一个内存块，**该内存块尾部的部分内存便被拿掉，剩余部分内存的原先内容依然保留**。

注意：

1. 如果原先的内存块无法改变大小，realloc 将另外分配一块正确大小的内存，并把原先那块内存的内容复制到新的块上。因此，在使用 realloc 之后，就不能再使用指向旧内存的指针，而是应该改用 realloc 所返回的指针；
2. 如果 realloc 的第一个参数是 NULL，那么它的行为就和 malloc 一模一样。

```c++
int *p = (int *)calloc(8, sizeof(int));
int *q = (int *)realloc(p, 16 * sizeof(int));
```

